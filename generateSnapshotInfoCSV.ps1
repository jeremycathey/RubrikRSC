######Beginning of rscConnect Function
function rscConnect() {
  [CmdletBinding(DefaultParameterSetName = 'ServiceAccountFile')]
  param (
      [Parameter(ParameterSetName = 'ServiceAccountFile')]
      [String]$ServiceAccountPath,
      [Parameter(ParameterSetName = 'AccessToken')]
      [String]$AccessToken
  )
  <#
  .SYNOPSIS

   Connects to an instance of Rubrik Security Cloud using an Access Token or Service Account File

  .DESCRIPTION

  Connects to an instance of Rubrik Security Cloud using an Access Token or Service Account File

  .EXAMPLE

  The Service Account JSON can be downloaded from the GUI when creating a service account.

  PS> Connect-RubrikSecurityCloud -Path ~/.rubrik/myserviceaccount.json

  .EXAMPLE

  Connect to your Rubrik Security Cloud instance using access token, generated by an external auth mechanism (Like the Rubrik UI)

  PS> Connect-RubrikSecurityCloud -AccessToken "Access Token from Browser session or another vault or script that has authenticated using a Servce Account"

  #>

  Write-Information -Message "Info: Attempting to read the Service Account file located at $($ServiceAccountPath)"
  try {
      switch ($PSCmdlet.ParameterSetName) {
          'ServiceAccountFile' {
              $serviceAccountFile = Get-Content -Path $ServiceAccountPath -ErrorAction Stop | ConvertFrom-Json
              $payload = @{
                  grant_type = "client_credentials";
                  client_id = $serviceAccountFile.client_id;
                  client_secret = $serviceAccountFile.client_secret
              }   
          
              Write-Debug -Message "Determing if the Service Account file contains all required variables."
              $missingServiceAccount = @()
              if ($null -eq $serviceAccountFile.client_id) {
                  $missingServiceAccount += "'client_id'"
              }
          
              if ($null -eq $serviceAccountFile.client_secret) {
                  $missingServiceAccount += "'client_secret'"
              }
          
              if ($null -eq $serviceAccountFile.access_token_uri) {
                  $missingServiceAccount += "'access_token_uri'"
              }
          
          
              if ($missingServiceAccount.count -gt 0){
                  throw "The Service Account JSON secret file is missing the required paramaters: $missingServiceAccount"
              }

              $headers = @{
                  'Content-Type' = 'application/json';
                  'Accept'       = 'application/json';
              }

              Write-Debug -Message "Connecting to the Polaris GraphQL API using the Service Account JSON file."
              $response = Invoke-RestMethod -Method POST -Uri $serviceAccountFile.access_token_uri -Body $($payload | ConvertTo-JSON -Depth 100) -Headers $headers
              $AccessToken = "Bearer " + $response.access_token
              $rscURL  = $serviceAccountFile.access_token_uri.Replace("/api/client_token", "/api/graphql")
          }
          'AccessToken' {
              $rscURL = getUrlFromJwt -jwt $AccessToken.split(" ")[1]
          }
          Default {}
      }
      
  }
  catch {      
      throw $_.Exception
  }
  
  Write-Verbose -Message "Creating the Rubrik Polaris Connection Global variable."
  $global:rscConnection = @{
      access_token      = $AccessToken
      rscURL        = $rscURL
  }
  Write-Output "Connected!"
}
######End of rscConnect Function


######Beginning of get-SnappableIDs Function
function get-SnappableIDs{
[CmdletBinding()]

  param (
      [parameter(Mandatory=$true)]
      [string]$clusterID
  )

process {
    try{

        $snappableIDs = @()

        $variables = "{
          `"input`":{
            `"clusterUuid`":`"${clusterID}`",
            `"sortParam`":{
              `"sortOrder`":`"ASC`",
              `"type`":`"NAME`"
            },
            `"retentionSlaDomainIds`":[],
            `"objectTypes`":[],
            `"unmanagedStatuses`":[]
          },
          `"first`":500  
        }"

        $query = @'
        query SnapshotManagementGlobalObjectsQuery($input: UnmanagedObjectsInput!, $after: String, $first: Int) {
          unmanagedObjects(input: $input, first: $first, after: $after) {
            edges {
              cursor
              node {
                archiveStorage
                hasSnapshotsWithPolicy
                id
                workloadId
                isRemote
                localStorage
                name
                objectType
                physicalLocation {
                  name
                  managedId
                  __typename
                }
                unmanagedStatus
                snapshotCount
                retentionSlaDomainId
                retentionSlaDomainName
                retentionSlaDomainRscManagedId
                region {
                  awsNativeRegion
                  azureNativeRegion
                  gcpNativeRegion
                  __typename
                }
                cloudAccountId
                cloudAccountName
                pendingSla {
                  ...SLADomainFragment
                  __typename
                }
                effectiveSlaDomain {
                  ...EffectiveSlaDomainFragment
                  __typename
                }
                cluster {
                  id
                  name
                  version
                  status
                  __typename
                }
                recoveryInfo {
                  isRefreshInProgressOpt
                  lastUpdatedTimeOpt
                  locationId
                  newWorkloadId
                  oldWorkloadId
                  __typename
                }
                __typename
              }
              __typename
            }
            pageInfo {
              endCursor
              hasPreviousPage
              hasNextPage
              __typename
            }
            __typename
          }
        }
        
        fragment EffectiveSlaDomainFragment on SlaDomain {
          id
          name
          ... on GlobalSlaReply {
            isRetentionLockedSla
            retentionLockMode
            __typename
          }
          ... on ClusterSlaDomain {
            fid
            cluster {
              id
              name
              __typename
            }
            isRetentionLockedSla
            retentionLockMode
            __typename
          }
          __typename
        }
        
        fragment SLADomainFragment on SlaDomain {
          id
          name
          ... on ClusterSlaDomain {
            fid
            cluster {
              id
              name
              __typename
            }
            __typename
          }
          __typename
        }
'@

            $headers = @{
            'Content-Type' = 'application/json';
            'Accept'       = 'application/json';
            'Authorization' = $rscConnection.access_token
            }

          $JSON_BODY = @{
            "variables" = $variables
            "query" = $query
        }
        $JSON_BODY = $JSON_BODY | ConvertTo-Json
        $result = Invoke-WebRequest -Uri $rscConnection.rscURL -Method POST -Headers $headers -Body $JSON_BODY
        $snappableIDs += (((($result.content | ConvertFrom-Json).data).unmanagedObjects).edges).node

        while ((((($result.content | ConvertFrom-Json).data).unmanagedObjects).pageInfo).hasNextPage -eq $true){
          $endCursor = ((((($result.content) | ConvertFrom-Json).data).unmanagedObjects).pageinfo).endCursor
          Write-Host ("Paging through another 500 snappable objects. Looking at End Cursor " + $endCursor)
          $variables = "{
            `"input`":{
              `"clusterUuid`":`"${clusterID}`",
              `"sortParam`":{
                `"sortOrder`":`"ASC`",
                `"type`":`"NAME`"
              },
              `"retentionSlaDomainIds`":[],
              `"objectTypes`":[],
              `"unmanagedStatuses`":[]
            },
            `"first`":500,
            `"after`": `"${endCursor}`"
          }"

          $JSON_BODY = @{
              "variables" = $variables
              "query" = $query
          }
          $JSON_BODY = $JSON_BODY | ConvertTo-Json
          $result = Invoke-WebRequest -Uri $rscConnection.rscURL -Method POST -Headers $headers -Body $JSON_BODY
          $snappableIDs += (((($result.content | ConvertFrom-Json).data).unmanagedObjects).edges).node
      }

    }

    Catch{
        Write-Error("Error $($_)")
    }
}
End{
    return $snappableIDs
}

}
######End of get-snappableIDs Function


######Beginning of get-SnapshotInfo Function
function get-SnapshotInfo{
  [CmdletBinding()]

  param (
      [parameter(Mandatory=$true)]
      [string]$snappableId,
      #snappableId = FID, not ID
      [int32]$numDays
  )
  process {
      try{

          #Set Timeframe to scan based on $DaysToReport
          $InFormat = "yyyy-MM-ddTHH:mm:ss.fffZ"
          #Setting current date to n - 1 to account for backups that run in the evening, while the report runs earlier in the day. 
          $currentDate = ((Get-Date).AddDays(-1)).ToString($InFormat)
          $startDate = ($currentDate | Get-Date).AddDays("-" + $numDays) | Get-Date -Format $InFormat

          $snappableInfo = @()
          $variables = "{
              `"snappableId`": `"${snappableId}`",
              `"first`": 200,
              `"sortBy`": `"CREATION_TIME`",
              `"sortOrder`": `"DESC`",
              `"snapshotFilter`": [
                {
                  `"field`": `"SNAPSHOT_TYPE`",
                  `"typeFilters`": []
                },
                {
                  `"field`": `"IS_LEGALLY_HELD`",
                  `"text`": `"false`"
                }
              ],
              `"timeRange`": {
                  `"start`": `"${startDate}`",
                  `"end`": `"${currentDate}`"
                }
            }"

          $query = "query SnapshotsListSingleQuery(`$snappableId: String!, `$first: Int, `$after: String, `$snapshotFilter: [SnapshotQueryFilterInput!], `$sortBy: SnapshotQuerySortByField, `$sortOrder: SortOrder, `$timeRange: TimeRangeInput) {
              snapshotsListConnection: snapshotOfASnappableConnection(workloadId: `$snappableId, first: `$first, after: `$after, snapshotFilter: `$snapshotFilter, sortBy: `$sortBy, sortOrder: `$sortOrder, timeRange: `$timeRange) {
                edges {
                  cursor
                  node {
                    ...CdmSnapshotLatestUserNotesFragment
                    id
                    date
                    expirationDate
                    isOnDemandSnapshot
                    ... on CdmSnapshot {
                      cdmVersion
                      isRetentionLocked
                      isDownloadedSnapshot
                      cluster {
                        id
                        name
                        version
                        status
                        timezone
                      }
                      pendingSnapshotDeletion {
                        id: snapshotFid
                        status
                      }
                      slaDomain {
                        ...EffectiveSlaDomainFragment
                      }
                      pendingSla {
                        ...SLADomainFragment
                      }
                      snapshotRetentionInfo {
                        isCustomRetentionApplied
                        archivalInfos {
                          name
                          isExpirationDateCalculated
                          expirationTime
                          locationId
                        }
                        localInfo {
                          name
                          isExpirationDateCalculated
                          expirationTime
                        }
                        replicationInfos {
                          name
                          isExpirationDateCalculated
                          expirationTime
                          locationId
                          isExpirationInformationUnavailable
                        }
                      }
                      sapHanaAppMetadata {
                        backupId
                        backupPrefix
                        snapshotType
                        files {
                          backupFileSizeInBytes
                        }
                      }
                      legalHoldInfo {
                        shouldHoldInPlace
                      }
                    }
                    ... on PolarisSnapshot {
                      isDeletedFromSource
                      isDownloadedSnapshot
                      isReplica
                      isArchivalCopy
                      slaDomain {
                        name
                        ... on ClusterSlaDomain {
                          fid
                          cluster {
                            id
                            name
                          }
                        }
                        ... on GlobalSlaReply {
                          id
                        }
                      }
                    }
                  }
                }
                pageInfo {
                  endCursor
                  hasNextPage
                }
              }
            }

            fragment EffectiveSlaDomainFragment on SlaDomain {
              id
              name
              ... on GlobalSlaReply {
                isRetentionLockedSla
              }
              ... on ClusterSlaDomain {
                fid
                cluster {
                  id
                  name
                }
                isRetentionLockedSla
              }
            }

            fragment SLADomainFragment on SlaDomain {
              id
              name
              ... on ClusterSlaDomain {
                fid
                cluster {
                  id
                  name
                }
              }
            }

            fragment CdmSnapshotLatestUserNotesFragment on CdmSnapshot {
              latestUserNote {
                time
                userName
                userNote
              }
            }"

              $headers = @{
              'Content-Type' = 'application/json';
              'Accept'       = 'application/json';
              'Authorization' = $rscConnection.access_token
              }

            $JSON_BODY = @{
              "variables" = $variables
              "query" = $query
          }
          $JSON_BODY = $JSON_BODY | ConvertTo-Json
          $result = Invoke-WebRequest -Uri $rscConnection.rscURL -Method POST -Headers $headers -Body $JSON_BODY
          $snappableInfo += (((($result.content | ConvertFrom-Json).data).snapshotsListConnection).edges).node

          while ((((($result.content | ConvertFrom-Json).data).snapshotsListConnection).pageInfo).hasNextPage -eq $true){
              $endCursor = ((((($result.content) | ConvertFrom-Json).data).taskDetailConnection).pageinfo).endCursor
              Write-Host ("Paging through snapshots. Looking at End Cursor " + $endCursor)
              $variables = "{
                  `"snappableId`": `"${snappableId}`",
                  `"first`": 200,
                  `"sortBy`": `"CREATION_TIME`",
                  `"sortOrder`": `"DESC`",
                  `"snapshotFilter`": [
                    {
                      `"field`": `"SNAPSHOT_TYPE`",
                      `"typeFilters`": []
                    },
                    {
                      `"field`": `"IS_LEGALLY_HELD`",
                      `"text`": `"false`"
                    }
                  ],
                  `"timeRange`": {
                      `"start`": `"${startDate}`",
                      `"end`": `"${currentDate}`"
                    },
                  `"after`": `"${endCursor}`"
                }"
              $JSON_BODY = @{
                  "variables" = $variables
                  "query" = $query
              }
              $JSON_BODY = $JSON_BODY | ConvertTo-Json
              $result = Invoke-WebRequest -Uri $rscConnection.rscURL -Method POST -Headers $headers -Body $JSON_BODY
              $snappableInfo += (((($result.content | ConvertFrom-Json).data).snapshotsListConnection).edges).node 
          }

      }

      Catch{
          Write-Error("Error $($_)")
      }
  }
  End{
      return $snappableInfo
  }

}
######End of get-SnapshotInfo Function

##############################################ust change path to path of your RSC Service Account JSON File##############################################

#Call rscConnect to get Service Account Contents & Get Access Token
rscConnect -ServiceAccountPath ~/.rubrik/gaia-service-account-file.json

##############################################ust change path to path of your RSC Service Account JSON File##############################################

###############################################################Variable Assignment Required##############################################################

#ID of cluster you wish to scan for ondemand snapshots
$clstID = ""
$csvExportPath = ""
###############################################################Variable Assignment Required##############################################################

#Create Array for snappable object IDs
$snappableIDArray = @()
$data = @()

# Create a custom object for onDemand Snapshot Information
$SnapshotDetailsdInfo = New-Object -TypeName PSObject -Property @{
  snappable_name = New-Object System.Collections.ArrayList
  snappable_id = New-Object System.Collections.ArrayList
  snappable_objectType = New-Object System.Collections.ArrayList
  snapshot_id = New-Object System.Collections.ArrayList
  snapshot_SLAName = New-Object System.Collections.ArrayList
  snapshot_clusterName = New-Object System.Collections.ArrayList
  snapshot_clusterID = New-Object System.Collections.ArrayList
  snapshot_date = New-Object System.Collections.ArrayList
  snapshot_expirationdate = New-Object System.Collections.ArrayList
}

$snappableIDArray = get-SnappableIDs -clusterID $clstID

foreach ($snap in $snappableIDArray) {
$snapshotDetails = get-SnapshotInfo -snappableId $snap.id -numDays 365
foreach ($entry in $snapshotDetails) {
    [void]$SnapshotDetailsdInfo.snappable_name.Add($snap.name)
    [void]$SnapshotDetailsdInfo.snappable_id.Add($snap.id)
    [void]$SnapshotDetailsdInfo.snappable_objectType.Add($snap.objectType)
    [void]$SnapshotDetailsdInfo.snapshot_id.Add($entry.id)
    [void]$SnapshotDetailsdInfo.snapshot_SLAName.Add($entry.slaDomain.name)
    [void]$SnapshotDetailsdInfo.snapshot_clusterName.Add($entry.cluster.name)
    [void]$SnapshotDetailsdInfo.snapshot_clusterID.Add($entry.cluster.id)
    [void]$SnapshotDetailsdInfo.snapshot_date.Add($entry.date)
    [void]$SnapshotDetailsdInfo.snapshot_expirationdate.Add($entry.snapshotRetentionInfo.localInfo.expirationTime)
}
}

# Iterate through the elements of each array to display them for verification
for ($i = 0; $i -lt $SnapshotDetailsdInfo.snappable_name.Count; $i++) {
  # Access each element from the array lists based on the index $i
  $snappableName = $SnapshotDetailsdInfo.snappable_name[$i]
  $snappableId = $SnapshotDetailsdInfo.snappable_id[$i]
  $snappableObjectType = $SnapshotDetailsdInfo.snappable_objectType[$i]
  $snapshotId = $SnapshotDetailsdInfo.snapshot_id[$i]
  $snapshostSLAName = $SnapshotDetailsdInfo.snapshot_SLAName[$i]
  $snapshotClusterName = $SnapshotDetailsdInfo.snapshot_clusterName[$i]
  $snapshotClusterID = $SnapshotDetailsdInfo.snapshot_clusterID[$i]
  $snapshotDate = $SnapshotDetailsdInfo.snapshot_date[$i]
  $snapshotExpirationDate = $SnapshotDetailsdInfo.snapshot_expirationdate[$i]
  
  # Create a custom object with the current item's data
  $obj = New-Object PSObject -Property @{
    ObjectName = $snappableName
    ObjectID = $snappableId
    ObjectType = $snappableObjectType
    SnapshotID = $snapshotId
    SnapshotSLAName = $snapshostSLAName
    SnapshotClusterName = $snapshotClusterName
    SnapshotClusterID = $snapshotClusterID
    SnapshotDate = $snapshotDate
    SnapshotExpirationDate = $snapshotExpirationDate
  }

  # Add the object to the data array
  $data += $obj

}

# Export the $data array to a CSV file, specifying the order of columns
$data | Select-Object -Property ObjectName, ObjectID, ObjectType, SnapshotID, SnapshotSLAName, SnapshotClusterName, SnapshotClusterID, SnapshotDate, SnapshotExpirationDate |
    Export-Csv -Path $csvExportPath -NoTypeInformation
